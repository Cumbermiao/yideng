### 1. each/foreach
- 该方法接收三个参数：list，iteratee：遍历list对每个元素进行操作的函数，[context]可选对iteratee的this绑定的上下文。
- list如果是类数组数据，iteratee的参数：element,index,list ,如果是对象类型则iteratee参数为value,key.list。
```
_.each = _.forEach = function (obj, iteratee, context) {
    //绑定iteratee中的this为context
    iteratee = optimizeCb(iteratee, context);
    var i, length;
    //如果obj是类数组类型的数据，使用for循环遍历obj中的元素
    if (isArrayLike(obj)) {
        for (i = 0, length = obj.length; i < length; i++) {
            iteratee(obj[i], i, obj);
        }
    } else {
        //如果为对象，获取obj的所有key的集合，使用for循环遍历obj的key，value
        var keys = _.keys(obj);
        for (i = 0, length = keys.length; i < length; i++) {
            iteratee(obj[keys[i]], keys[i], obj);
        }
    }
    //为了链式调用，返回obj
    return obj;
};
```

### 2. optimizeCb（内置函数）
- 该方法接收三个参数：func,context,argCount,将func中的this绑定到context上。并将func封装，可以让underscore中的其他函数调用。
```
var optimizeCb = function (func, context, argCount) {
    //void 0 = undefined=true,判断实参中有没有传context，没有则直接返回 func
        if (context === void 0) return func;
        //判断argCount的个数：func中传入的实参，默认为3即类数组相关操作的参数：value,index,collection
        switch (argCount == null ? 3 : argCount) {
            case 1:
                return function (value) {
                    return func.call(context, value);
                };
                // The 2-argument case is omitted because we’re not using it.
            case 3:
                return function (value, index, collection) {
                    return func.call(context, value, index, collection);
                };
            case 4:
                return function (accumulator, value, index, collection) {
                    return func.call(context, accumulator, value, index, collection);
                };
        }
        return function () {
            return func.apply(context, arguments);
        };
    };
```

### 3 map/collect
```
 _.map = _.collect = function (obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    //如果obj为类数组类型，keys=false,length=obj.length；为Object时，keys=Object.keys(obj),length=keys.length;
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length,
        results = Array(length);
    for (var index = 0; index < length; index++) {
        var currentKey = keys ? keys[index] : index;
        results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
};
```

### 4 cb
- 生成能够遍历 集合中每个元素的回调
```
var cb = function (value, context, argCount) {
    if (_.iteratee !== builtinIteratee) return _.iteratee(value, context);
    if (value == null) return _.identity;
    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
    if (_.isObject(value) && !_.isArray(value)) return _.matcher(value);
    return _.property(value);
};
```

### 5 createReduce
```
// dir 表示reduce的方向
var createReduce = function (dir) {
        // 包装代码在一个单独的函数中重新分配参数变量，而不是访问`arguments.length`以避免执行命中。
        var reducer = function (obj, iteratee, memo, initial) {
            //如果dir为1，则index=0，正序执行，否则index=length-1，倒序执行
            var keys = !isArrayLike(obj) && _.keys(obj),
                length = (keys || obj).length,
                index = dir > 0 ? 0 : length - 1;
            //根据reduce的实参判断有没有初始值，memo为初始值，没有则为第一个元素的值
            if (!initial) {
                memo = obj[keys ? keys[index] : index];
                index += dir;
            }
            for (; index >= 0 && index < length; index += dir) {
                var currentKey = keys ? keys[index] : index;
                memo = iteratee(memo, obj[currentKey], currentKey, obj);
            }
            return memo;
        };

        return function (obj, iteratee, memo, context) {
            var initial = arguments.length >= 3;
            return reducer(obj, optimizeCb(iteratee, context, 4), memo, initial);
        };
    };
```

### reduce/foldl/inject
```
_.reduce = _.foldl = _.inject = createReduce(1);
```

### reduceRight
```
_.reduceRight = _.foldr = createReduce(-1);
```

###  find/detect
- 接收三个参数：obj要查找的对象或数组，predicate满足条件的函数。

```
_.find = _.detect = function (obj, predicate, context) {
    //判断obj是对象还是数组，使用不同的方法
    var keyFinder = isArrayLike(obj) ? _.findIndex : _.findKey;

    var key = keyFinder(obj, predicate, context);
    if (key !== void 0 && key !== -1) return obj[key];
};
```

### findIndex/findLastIndex
```
//dir 判断从前还是从最后开始查找
var createPredicateIndexFinder = function (dir) {
    return function (array, predicate, context) {
        //生成判断函数
        predicate = cb(predicate, context);
        var length = getLength(array);
        var index = dir > 0 ? 0 : length - 1;
        //遍历array，如果predicate为true，则返回index
        for (; index >= 0 && index < length; index += dir) {
            if (predicate(array[index], index, array)) return index;
        }
        return -1;
    };
};

_.findIndex = createPredicateIndexFinder(1);
_.findLastIndex = createPredicateIndexFinder(-1);
```


### filter/select
- 使用each方法遍历数组或对象，如果满足则忘result中push该元素。
```
_.filter = _.select = function (obj, predicate, context) {
    var results = [];
    predicate = cb(predicate, context);
    _.each(obj, function (value, index, list) {
        if (predicate(value, index, list)) results.push(value);
    });
    return results;
};
```

### reject
- 返回所有不满足条件的元素。
- 原理：也是使用each遍历，如果不满足则往result中push。
- 思想：封装一个相反的函数，使用filter将所有相反的元素返回出来。
```
_.negate = function (predicate) {
    return function () {
        return !predicate.apply(this, arguments);
    };
};

_.reject = function (obj, predicate, context) {
    return _.filter(obj, _.negate(cb(predicate)), context);
};
```

### every/all
- 判断所有元素是否都满足条件，都满足则返回true，否则返回false
```
_.every = _.all = function (obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
        var currentKey = keys ? keys[index] : index;
        if (!predicate(obj[currentKey], currentKey, obj)) return false;
    }
    return true;
};
```