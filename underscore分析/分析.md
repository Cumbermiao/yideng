### 1. each/foreach
- 该方法接收三个参数：list，iteratee：遍历list对每个元素进行操作的函数，[context]可选对iteratee的this绑定的上下文。
- list如果是类数组数据，iteratee的参数：element,index,list ,如果是对象类型则iteratee参数为value,key.list。
```
_.each = _.forEach = function (obj, iteratee, context) {
    //绑定iteratee中的this为context
    iteratee = optimizeCb(iteratee, context);
    var i, length;
    //如果obj是类数组类型的数据，使用for循环遍历obj中的元素
    if (isArrayLike(obj)) {
        for (i = 0, length = obj.length; i < length; i++) {
            iteratee(obj[i], i, obj);
        }
    } else {
        //如果为对象，获取obj的所有key的集合，使用for循环遍历obj的key，value
        var keys = _.keys(obj);
        for (i = 0, length = keys.length; i < length; i++) {
            iteratee(obj[keys[i]], keys[i], obj);
        }
    }
    //为了链式调用，返回obj
    return obj;
};
```

### 2. optimizeCb（内置函数）
- 该方法接收三个参数：func,context,argCount,将func中的this绑定到context上。并将func封装，可以让underscore中的其他函数调用。
```
var optimizeCb = function (func, context, argCount) {
    //void 0 = undefined=true,判断实参中有没有传context，没有则直接返回 func
        if (context === void 0) return func;
        //判断argCount的个数：func中传入的实参，默认为3即类数组相关操作的参数：value,index,collection
        switch (argCount == null ? 3 : argCount) {
            case 1:
                return function (value) {
                    return func.call(context, value);
                };
                // The 2-argument case is omitted because we’re not using it.
            case 3:
                return function (value, index, collection) {
                    return func.call(context, value, index, collection);
                };
            case 4:
                return function (accumulator, value, index, collection) {
                    return func.call(context, accumulator, value, index, collection);
                };
        }
        return function () {
            return func.apply(context, arguments);
        };
    };
```

### 3 map/collect
```
 _.map = _.collect = function (obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    //如果obj为类数组类型，keys=false,length=obj.length；为Object时，keys=Object.keys(obj),length=keys.length;
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length,
        results = Array(length);
    for (var index = 0; index < length; index++) {
        var currentKey = keys ? keys[index] : index;
        results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
};
```

### 4 cb
- 生成能够遍历 集合中每个元素的回调
```
var cb = function (value, context, argCount) {
    if (_.iteratee !== builtinIteratee) return _.iteratee(value, context);
    if (value == null) return _.identity;
    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
    if (_.isObject(value) && !_.isArray(value)) return _.matcher(value);
    return _.property(value);
};
```

### 5 createReduce
```
// dir 表示reduce的方向
var createReduce = function (dir) {
        // 包装代码在一个单独的函数中重新分配参数变量，而不是访问`arguments.length`以避免执行命中。
        var reducer = function (obj, iteratee, memo, initial) {
            //如果dir为1，则index=0，正序执行，否则index=length-1，倒序执行
            var keys = !isArrayLike(obj) && _.keys(obj),
                length = (keys || obj).length,
                index = dir > 0 ? 0 : length - 1;
            //根据reduce的实参判断有没有初始值，memo为初始值，没有则为第一个元素的值
            if (!initial) {
                memo = obj[keys ? keys[index] : index];
                index += dir;
            }
            for (; index >= 0 && index < length; index += dir) {
                var currentKey = keys ? keys[index] : index;
                memo = iteratee(memo, obj[currentKey], currentKey, obj);
            }
            return memo;
        };

        return function (obj, iteratee, memo, context) {
            var initial = arguments.length >= 3;
            return reducer(obj, optimizeCb(iteratee, context, 4), memo, initial);
        };
    };
```

### reduce/foldl/inject
```
_.reduce = _.foldl = _.inject = createReduce(1);
```

### reduceRight
```
_.reduceRight = _.foldr = createReduce(-1);
```

###  find/detect
- 接收三个参数：obj要查找的对象或数组，predicate满足条件的函数。

```
_.find = _.detect = function (obj, predicate, context) {
    //判断obj是对象还是数组，使用不同的方法
    var keyFinder = isArrayLike(obj) ? _.findIndex : _.findKey;

    var key = keyFinder(obj, predicate, context);
    if (key !== void 0 && key !== -1) return obj[key];
};
```

### findIndex/findLastIndex
```
//dir 判断从前还是从最后开始查找
var createPredicateIndexFinder = function (dir) {
    return function (array, predicate, context) {
        //生成判断函数
        predicate = cb(predicate, context);
        var length = getLength(array);
        var index = dir > 0 ? 0 : length - 1;
        //遍历array，如果predicate为true，则返回index
        for (; index >= 0 && index < length; index += dir) {
            if (predicate(array[index], index, array)) return index;
        }
        return -1;
    };
};

_.findIndex = createPredicateIndexFinder(1);
_.findLastIndex = createPredicateIndexFinder(-1);
```


### filter/select
- 使用each方法遍历数组或对象，如果满足则忘result中push该元素。
```
_.filter = _.select = function (obj, predicate, context) {
    var results = [];
    predicate = cb(predicate, context);
    _.each(obj, function (value, index, list) {
        if (predicate(value, index, list)) results.push(value);
    });
    return results;
};
```

### reject
- 返回所有不满足条件的元素。
- 原理：也是使用each遍历，如果不满足则往result中push。
- 思想：封装一个相反的函数，使用filter将所有相反的元素返回出来。
```
_.negate = function (predicate) {
    return function () {
        return !predicate.apply(this, arguments);
    };
};

_.reject = function (obj, predicate, context) {
    return _.filter(obj, _.negate(cb(predicate)), context);
};
```

### every/all
- 判断所有元素是否都满足条件，都满足则返回true，否则返回false
```
_.every = _.all = function (obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
        var currentKey = keys ? keys[index] : index;
        if (!predicate(obj[currentKey], currentKey, obj)) return false;
    }
    return true;
};
```

###  some/any
- 与every方法相反，只要有一个满足条件就返回 true
_.some = _.any = function (obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
        var currentKey = keys ? keys[index] : index;
        if (predicate(obj[currentKey], currentKey, obj)) return true;
    }
    return false;
};

### contain/includes

```
//个人实现
_.contain = _.includes= function(obj,value,fromIndex){
    var keys = !isArrayLike(obj)&&_.keys(obj),
    length = (keys||obj).length;
    for(var index =fromIndex||0;index<length;index++){
        var currentKey = keys?keys[index]:index
        if(obj[currentKey]===value){
            return true
        }
    }
}
function test(index,guard){
    if (typeof index != 'number' || guard) console.log('not number')
    else{
        console.log('is number')
    }
}
function test1(index){
    if (typeof index != 'number') console.log('not number')
    else{
        console.log('is number')
    }
}
//源码
_.contains = _.includes = _.include = function (obj, item, fromIndex, guard) {
    if (!isArrayLike(obj)) obj = _.values(obj);
    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
    return _.indexOf(obj, item, fromIndex) >= 0;
};
```
### invoke 
- 与map方法类似，使用 path 方法作用于数组的每一个元素
- 多余的参数args会传递给 path 方法
```
_.invoke = restArguments(function (obj, path, args) {
    var contextPath, func;
    if (_.isFunction(path)) {
        func = path;
    } else if (_.isArray(path)) {
        contextPath = path.slice(0, -1);
        path = path[path.length - 1];
    }
    return _.map(obj, function (context) {
        var method = func;
        if (!method) {
            if (contextPath && contextPath.length) {
                context = deepGet(context, contextPath);
            }
            if (context == null) return void 0;
            method = context[path];
        }
        return method == null ? method : method.apply(context, args);
    });
});
```
### deepGet
- 获取 path 里的元素，并返回。
```
var deepGet = function (obj, path) {
    var length = path.length;
    for (var i = 0; i < length; i++) {
        if (obj == null) return void 0;
        obj = obj[path[i]];
    }
    return length ? obj : void 0;
};
```

### restArguments
- 将函数里可能会传的参数 args 处理成一个数组传进去。
```
var restArguments = function (func, startIndex) {
    startIndex = startIndex == null ? func.length - 1 : +startIndex;
    return function () {
        var length = Math.max(arguments.length - startIndex, 0),
            rest = Array(length),
            index = 0;
        for (; index < length; index++) {
            rest[index] = arguments[index + startIndex];
        }
        switch (startIndex) {
            case 0:
                return func.call(this, rest);
            case 1:
                return func.call(this, arguments[0], rest);
            case 2:
                return func.call(this, arguments[0], arguments[1], rest);
        }
        var args = Array(startIndex + 1);
        for (index = 0; index < startIndex; index++) {
            args[index] = arguments[index];
        }
        args[startIndex] = rest;
        return func.apply(this, args);
    };
};
```

### pluck
- 萃取数组对象中某属性值，返回一个数组。
```
_.pluck = function (obj, key) {
    return _.map(obj, _.property(key));
};
```

### property

```
_.property = function (path) {
    if (!_.isArray(path)) {
        return shallowProperty(path);
    }
    return function (obj) {
        return deepGet(obj, path);
    };
};
```
### shallowProperty
```
var shallowProperty = function (key) {
    return function (obj) {
        return obj == null ? void 0 : obj[key];
    };
};
```
