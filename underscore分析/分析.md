### 1。each/foreach
- 该方法接收三个参数：list，iteratee：遍历list对每个元素进行操作的函数，[context]可选对iteratee的this绑定的上下文。
- list如果是类数组数据，iteratee的参数：element,index,list ,如果是对象类型则iteratee参数为value,key.list。
```
_.each = _.forEach = function (obj, iteratee, context) {
    //绑定iteratee中的this为context
    iteratee = optimizeCb(iteratee, context);
    var i, length;
    //如果obj是类数组类型的数据，使用for循环遍历obj中的元素
    if (isArrayLike(obj)) {
        for (i = 0, length = obj.length; i < length; i++) {
            iteratee(obj[i], i, obj);
        }
    } else {
        //如果为对象，获取obj的所有key的集合，使用for循环遍历obj的key，value
        var keys = _.keys(obj);
        for (i = 0, length = keys.length; i < length; i++) {
            iteratee(obj[keys[i]], keys[i], obj);
        }
    }
    //为了链式调用，返回obj
    return obj;
};
```

### 2. optimizeCb（内置函数）
- 该方法接收三个参数：func,context,argCount,将func中的this绑定到context上。并将func封装，可以让underscore中的其他函数调用。
```
var optimizeCb = function (func, context, argCount) {
    //void 0 = undefined=true,判断实参中有没有context，没有则直接返回 func
        if (context === void 0) return func;
        //判断argCount的个数：func中传入的实参，默认为3即类数组相关操作的参数：value,index,collection
        switch (argCount == null ? 3 : argCount) {
            case 1:
                return function (value) {
                    return func.call(context, value);
                };
                // The 2-argument case is omitted because we’re not using it.
            case 3:
                return function (value, index, collection) {
                    return func.call(context, value, index, collection);
                };
            case 4:
                return function (accumulator, value, index, collection) {
                    return func.call(context, accumulator, value, index, collection);
                };
        }
        return function () {
            return func.apply(context, arguments);
        };
    };
```

### 3 map/collect
```
 _.map = _.collect = function (obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    //如果obj为类数组类型，keys=false,length=obj.length；为Object时，keys=Object.keys(obj),length=keys.length;
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length,
        results = Array(length);
    for (var index = 0; index < length; index++) {
        var currentKey = keys ? keys[index] : index;
        results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
};
```

### 4 cb

### 5 createReduce
```
// dir 表示reduce的方向
var createReduce = function (dir) {
        // 包装代码在一个单独的函数中重新分配参数变量，而不是访问`arguments.length`以避免执行命中。
        var reducer = function (obj, iteratee, memo, initial) {
            //如果dir为1，则index=0，正序执行，否则index=length-1，倒序执行
            var keys = !isArrayLike(obj) && _.keys(obj),
                length = (keys || obj).length,
                index = dir > 0 ? 0 : length - 1;
            //根据reduce的实参判断有没有初始值，memo为初始值，没有则为第一个元素的值
            if (!initial) {
                memo = obj[keys ? keys[index] : index];
                index += dir;
            }
            for (; index >= 0 && index < length; index += dir) {
                var currentKey = keys ? keys[index] : index;
                memo = iteratee(memo, obj[currentKey], currentKey, obj);
            }
            return memo;
        };

        return function (obj, iteratee, memo, context) {
            var initial = arguments.length >= 3;
            return reducer(obj, optimizeCb(iteratee, context, 4), memo, initial);
        };
    };
```

### reduce/foldl/inject
```
_.reduce = _.foldl = _.inject = createReduce(1);
```

### reduceRight
```
_.reduceRight = _.foldr = createReduce(-1);
```