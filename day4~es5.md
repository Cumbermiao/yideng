- with 会创建全局属性
```
var obj ={a:1}
with(obj){
    b = 10
}
alert(b)//10, with中由于obj没有b，b被声明到window中。
```
- if...else 变量声明提升
```
if(false){
    var a =10
}
alert(a) //undefined 
//if...else... 没有块级作用域，里面的变量还是会被提升声明
```
- let 使用的是 es5 中的块级作用域实现, es5中的块级作用域：with,try..,catch,eval
```
try{
	throw(20)
}.catch(a=>{
	console.log(a)
	})
```
- 函数的声明提升在变量的声明之前，所以同名的函数会被变量覆盖。但是如果在同名变量赋值之前使用该变量，由于 变量的只是声明未赋值 所以解析时，变量的声明会被忽略，所以还是函数。

- vo ao

- es6暂时性死区
```
var a =10 
if(true){
	a=100
	let a
}
//es6 中明确规定，let、const 这种块级声明，在变量声明之前，变量都是不可用的。所以必须先声明再使用，语法上成为暂时性死区。
```

- 立即执行函数的本质其实使用运算符让浏览器将函数当成一个表达式执行。

### 原型链
1. 所有函数数据类型都自带一个 prototype 属性，它存储的值是一个对象类型的值，浏览器默认为其开辟一个堆内存。
2. 只有在浏览器为prototype开辟的堆内存上有一个默认的constructor属性，指向当前的函数。
3. 每一个对象数据类型，都天生自带一个 __proto__ 属性，指向当前对象所属的原型。（ie不支持__proto__ 属性）

### this指向判断
1. 自执行函数指向 window
2. 方法名前是否有调用，有则指向调用者
3. 在箭头函数中，this指向的是当前对象的父级作用域

### new 一个函数发生了什么？
1. 创建一个空对象 obj
2. 把obj 绑定到函数的上下文中（this->obj）
3. 执行函数
4. 如果函数没有返回或者返回的是值类型则返回obj ，返回的如果是对象类型则返回对应的内容。